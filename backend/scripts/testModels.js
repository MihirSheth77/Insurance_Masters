#!/usr/bin/env node

// Test MongoDB Models Script
// Validates all Mongoose schemas and their functionality

const { databaseConnection } = require('../src/config/database');

// Import all models
const County = require('../src/models/County');
const Issuer = require('../src/models/Issuer');
const Plan = require('../src/models/Plan');
const Pricing = require('../src/models/Pricing');
const ZipCounty = require('../src/models/ZipCounty');
const PlanCounty = require('../src/models/PlanCounty');
const RatingArea = require('../src/models/RatingArea');
const ServiceArea = require('../src/models/ServiceArea');
const ServiceAreaZipCounty = require('../src/models/ServiceAreaZipCounty');
const Group = require('../src/models/Group');
const ICHRAClass = require('../src/models/ICHRAClass');
const Member = require('../src/models/Member');
const QuoteResult = require('../src/models/QuoteResult');

console.log('üß™ Testing MongoDB Models & Schemas');
console.log('=====================================');

async function testModels() {
  try {
    // Connect to database
    console.log('üîå Connecting to database...');
    await databaseConnection.connect();

    // Test data for each model
    const testData = {
      county: {
        fipsCode: '48001',
        name: 'Anderson County',
        state: 'TX',
        stateId: 'TX',
        csvId: 1,
        serviceAreaCount: 5,
        ratingAreaCount: 3
      },
      
      issuer: {
        issuerId: '12345',
        name: 'Test Insurance Company',
        state: 'TX',
        csvId: 1
      },
      
      ratingArea: {
        id: 'TX01',
        stateId: 'TX'
      },
      
      serviceArea: {
        id: 'SA001-2024',
        issuerId: '12345',
        name: 'Test Service Area'
      },
      
      zipCounty: {
        zipCodeId: '123', // Changed to be within 1-572 range
        countyId: '48001',
        ratingAreaId: 'TX01',
        csvId: 1
      },
      
      plan: {
        planId: 'TEST123TX0000001',
        issuerId: '12345',
        name: 'Test Health Plan',
        displayName: 'Test Health Plan Display',
        carrierName: 'Test Insurance Company',
        marketType: 'individual',
        metalLevel: 'silver',
        level: 'silver',
        planType: 'PPO',
        hiossuerIdcId: 'HIOS123',
        serviceAreaId: 'SA001-2024',
        effectiveDate: new Date('2024-01-01'),
        expirationDate: new Date('2024-12-31'),
        deductibles: {
          individual: {
            inNetwork: 2000,
            outOfNetwork: 4000
          },
          family: {
            inNetwork: 4000,
            outOfNetwork: 8000
          }
        },
        copays: {
          primaryCare: "In-Network: $25 / Out-of-Network: $50",
          specialist: "In-Network: $50 / Out-of-Network: $100"
        }
      },
      
      pricing: {
        planId: 'TEST123TX0000001',
        ratingAreaId: 'TX01',
        effectiveDate: new Date('2024-01-01'),
        expirationDate: new Date('2024-12-31'),
        ageBasedPricing: new Map([
          ['21', { regular: 250.00, tobacco: 325.00 }], // Fixed: tobacco > regular
          ['30', { regular: 300.00, tobacco: 390.00 }], // Fixed: tobacco > regular
          ['40', { regular: 350.00, tobacco: 455.00 }]  // Fixed: tobacco > regular
        ]),
        familyStructurePricing: {
          individual: 300.00,
          couple: 600.00,
          family: 900.00,
          singleParent: 700.00
        }
      },
      
      planCounty: {
        planId: 'TEST123TX0000001',
        countyId: '48001'
      },
      
      serviceAreaZipCounty: {
        serviceAreaId: 'SA001-2024',
        zipCodeId: '123', // Changed to be within 1-572 range
        countyId: '48001'
      },
      
      group: {
        name: 'Test Company Inc', // Fixed: changed from groupName to name
        ideonGroupId: 'ideon_test_123',
        address: {
          street1: '123 Test Street', // Fixed: changed from street to street1
          city: 'Austin',
          state: 'TX',
          zipCode: '123', // Fixed: changed to be within 1-572 range
          county: 'Travis'
        },
        effectiveDate: new Date('2024-01-01')
      },
      
      ichraClass: {
        groupId: null, // Will be set after group creation
        className: 'Full-time Employees',
        description: 'All full-time employees',
        monthlyContribution: 400.00,
        ageBasedContributions: [
          { minAge: 18, maxAge: 29, contribution: 350.00 },
          { minAge: 30, maxAge: 39, contribution: 400.00 },
          { minAge: 40, maxAge: 64, contribution: 450.00 }
        ]
      },
      
      member: {
        groupId: null, // Will be set after group creation
        classId: null, // Will be set after class creation
        ideonMemberId: 'ideon_member_123',
        firstName: 'John',
        lastName: 'Doe',
        dateOfBirth: new Date('1990-05-15'),
        zipCode: '123', // Fixed: changed to be within 1-572 range
        tobaccoUse: false,
        previousContributions: {
          employerContribution: 450.00,
          memberContribution: 125.00,
          planName: 'Previous Test Plan'
        },
        dependents: [
          {
            firstName: 'Jane',
            lastName: 'Doe',
            dateOfBirth: new Date('1992-08-20'),
            relationship: 'spouse'
          }
        ]
      }
    };

    // Test each model
    const results = {};

    console.log('\nüìã Testing Geographic Models...');
    
    // Test County
    try {
      const county = new County(testData.county);
      await county.validate();
      await county.save();
      results.county = '‚úÖ County model works';
      console.log('‚úÖ County model validated and saved');
    } catch (error) {
      results.county = `‚ùå County model failed: ${error.message}`;
      console.log('‚ùå County model failed:', error.message);
    }

    // Test Issuer
    try {
      const issuer = new Issuer(testData.issuer);
      await issuer.validate();
      await issuer.save();
      results.issuer = '‚úÖ Issuer model works';
      console.log('‚úÖ Issuer model validated and saved');
    } catch (error) {
      results.issuer = `‚ùå Issuer model failed: ${error.message}`;
      console.log('‚ùå Issuer model failed:', error.message);
    }

    // Test RatingArea
    try {
      const ratingArea = new RatingArea(testData.ratingArea);
      await ratingArea.validate();
      await ratingArea.save();
      results.ratingArea = '‚úÖ RatingArea model works';
      console.log('‚úÖ RatingArea model validated and saved');
    } catch (error) {
      results.ratingArea = `‚ùå RatingArea model failed: ${error.message}`;
      console.log('‚ùå RatingArea model failed:', error.message);
    }

    // Test ServiceArea
    try {
      const serviceArea = new ServiceArea(testData.serviceArea);
      await serviceArea.validate();
      await serviceArea.save();
      results.serviceArea = '‚úÖ ServiceArea model works';
      console.log('‚úÖ ServiceArea model validated and saved');
    } catch (error) {
      results.serviceArea = `‚ùå ServiceArea model failed: ${error.message}`;
      console.log('‚ùå ServiceArea model failed:', error.message);
    }

    // Test ZipCounty
    try {
      const zipCounty = new ZipCounty(testData.zipCounty);
      await zipCounty.validate();
      await zipCounty.save();
      results.zipCounty = '‚úÖ ZipCounty model works';
      console.log('‚úÖ ZipCounty model validated and saved');
    } catch (error) {
      results.zipCounty = `‚ùå ZipCounty model failed: ${error.message}`;
      console.log('‚ùå ZipCounty model failed:', error.message);
    }

    console.log('\nüìã Testing Plan & Pricing Models...');

    // Test Plan
    try {
      const plan = new Plan(testData.plan);
      await plan.validate();
      await plan.save();
      results.plan = '‚úÖ Plan model works';
      console.log('‚úÖ Plan model validated and saved');
    } catch (error) {
      results.plan = `‚ùå Plan model failed: ${error.message}`;
      console.log('‚ùå Plan model failed:', error.message);
    }

    // Test Pricing
    try {
      const pricing = new Pricing(testData.pricing);
      await pricing.validate();
      await pricing.save();
      results.pricing = '‚úÖ Pricing model works';
      console.log('‚úÖ Pricing model validated and saved');
    } catch (error) {
      results.pricing = `‚ùå Pricing model failed: ${error.message}`;
      console.log('‚ùå Pricing model failed:', error.message);
    }

    // Test PlanCounty
    try {
      const planCounty = new PlanCounty(testData.planCounty);
      await planCounty.validate();
      await planCounty.save();
      results.planCounty = '‚úÖ PlanCounty model works';
      console.log('‚úÖ PlanCounty model validated and saved');
    } catch (error) {
      results.planCounty = `‚ùå PlanCounty model failed: ${error.message}`;
      console.log('‚ùå PlanCounty model failed:', error.message);
    }

    // Test ServiceAreaZipCounty
    try {
      const serviceAreaZipCounty = new ServiceAreaZipCounty(testData.serviceAreaZipCounty);
      await serviceAreaZipCounty.validate();
      await serviceAreaZipCounty.save();
      results.serviceAreaZipCounty = '‚úÖ ServiceAreaZipCounty model works';
      console.log('‚úÖ ServiceAreaZipCounty model validated and saved');
    } catch (error) {
      results.serviceAreaZipCounty = `‚ùå ServiceAreaZipCounty model failed: ${error.message}`;
      console.log('‚ùå ServiceAreaZipCounty model failed:', error.message);
    }

    console.log('\nüìã Testing Application Models...');

    // Test Group
    try {
      const group = new Group(testData.group);
      await group.validate();
      await group.save();
      
      // Update test data with created group ID
      testData.ichraClass.groupId = group._id;
      testData.member.groupId = group._id;
      
      results.group = '‚úÖ Group model works';
      console.log('‚úÖ Group model validated and saved');
    } catch (error) {
      results.group = `‚ùå Group model failed: ${error.message}`;
      console.log('‚ùå Group model failed:', error.message);
    }

    // Test ICHRAClass
    try {
      if (testData.ichraClass.groupId) {
        const ichraClass = new ICHRAClass(testData.ichraClass);
        await ichraClass.validate();
        await ichraClass.save();
        
        // Update test data with created class ID
        testData.member.classId = ichraClass._id;
        
        results.ichraClass = '‚úÖ ICHRAClass model works';
        console.log('‚úÖ ICHRAClass model validated and saved');
      } else {
        results.ichraClass = '‚ö†Ô∏è ICHRAClass skipped (no group ID)';
        console.log('‚ö†Ô∏è ICHRAClass skipped (no group ID)');
      }
    } catch (error) {
      results.ichraClass = `‚ùå ICHRAClass model failed: ${error.message}`;
      console.log('‚ùå ICHRAClass model failed:', error.message);
    }

    // Test Member
    try {
      if (testData.member.groupId && testData.member.classId) {
        const member = new Member(testData.member);
        await member.validate();
        await member.save();
        results.member = '‚úÖ Member model works';
        console.log('‚úÖ Member model validated and saved');
      } else {
        results.member = '‚ö†Ô∏è Member skipped (missing group or class ID)';
        console.log('‚ö†Ô∏è Member skipped (missing group or class ID)');
      }
    } catch (error) {
      results.member = `‚ùå Member model failed: ${error.message}`;
      console.log('‚ùå Member model failed:', error.message);
    }

    // Test QuoteResult
    try {
      if (testData.member.groupId) {
        const quoteResultData = {
          groupId: testData.member.groupId,
          quoteParameters: {
            effectiveDate: new Date('2024-01-01'),
            metalLevels: ['silver', 'gold'],
            planTypes: ['PPO', 'HMO']
          },
          plans: [
            {
              planId: 'TEST123TX0000001',
              planName: 'Test Health Plan',
              metalLevel: 'silver',
              monthlyPremium: 350.00,
              deductible: 2000,
              maxOutOfPocket: 8000
            }
          ],
          summary: {
            totalPlans: 1,
            averagePremium: 350.00,
            lowestPremium: 350.00,
            highestPremium: 350.00
          }
        };

        const quoteResult = new QuoteResult(quoteResultData);
        await quoteResult.validate();
        await quoteResult.save();
        results.quoteResult = '‚úÖ QuoteResult model works';
        console.log('‚úÖ QuoteResult model validated and saved');
      } else {
        results.quoteResult = '‚ö†Ô∏è QuoteResult skipped (no group ID)';
        console.log('‚ö†Ô∏è QuoteResult skipped (no group ID)');
      }
    } catch (error) {
      results.quoteResult = `‚ùå QuoteResult model failed: ${error.message}`;
      console.log('‚ùå QuoteResult model failed:', error.message);
    }

    // Summary
    console.log('\nüìä Test Results Summary');
    console.log('=======================');
    
    let passCount = 0;
    let totalCount = 0;
    
    Object.entries(results).forEach(([model, result]) => {
      console.log(`${model}: ${result}`);
      totalCount++;
      if (result.startsWith('‚úÖ')) passCount++;
    });
    
    console.log(`\nüéØ Overall Results: ${passCount}/${totalCount} models passed`);
    
    if (passCount === totalCount) {
      console.log('üéâ All models are working correctly!');
    } else {
      console.log('‚ö†Ô∏è Some models need attention.');
    }

    // Test database health
    const health = await databaseConnection.healthCheck();
    console.log('\nüè• Database Health:', health.healthy ? '‚úÖ Healthy' : '‚ùå Unhealthy');
    console.log('üìä Collections Created:', Object.keys(health.details.collections).length);

    return { success: passCount === totalCount, results, health };

  } catch (error) {
    console.error('üí• Test script failed:', error.message);
    throw error;
  }
}

// Run tests
async function runTests() {
  try {
    const results = await testModels();
    
    if (results.success) {
      console.log('\nüöÄ MongoDB implementation is ready!');
      process.exit(0);
    } else {
      console.log('\n‚ö†Ô∏è MongoDB implementation needs fixes.');
      process.exit(1);
    }
    
  } catch (error) {
    console.error('\nüí• MongoDB test failed:', error.message);
    process.exit(1);
  } finally {
    // Cleanup: disconnect from database
    try {
      await databaseConnection.disconnect();
    } catch (err) {
      console.error('Error disconnecting:', err.message);
    }
  }
}

// Handle graceful shutdown
process.on('SIGINT', async () => {
  console.log('\nüõë Test interrupted by user');
  try {
    await databaseConnection.disconnect();
  } catch (err) {
    console.error('Error during cleanup:', err.message);
  }
  process.exit(1);
});

if (require.main === module) {
  runTests();
}

module.exports = {
  testModels,
  runTests
}; 